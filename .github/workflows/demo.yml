name: Local Deploy via Self-Hosted Runner (no setup-dotnet)

on:
  push:
    branches: [ main ]
  workflow_dispatch: {}

concurrency:
  group: local-deploy
  cancel-in-progress: true

defaults:
  run:
    shell: powershell   # use Windows PowerShell on your self-hosted runner

env:
  DOTNET_EXE: C:\Program Files\dotnet\dotnet.exe
  TARGET_DIR: D:\Deploy\HelloVandit
  PORT: "5000"
  # If you want to pin your project path, uncomment and set this:
  # PROJ_DIR: src\HelloVandit

jobs:
  build-and-deploy:
    runs-on: self-hosted

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Sanity:print workspace and find csproj
        run: |
          $ErrorActionPreference = 'Stop'
          Write-Host "GITHUB_WORKSPACE = $env:GITHUB_WORKSPACE"
          Get-ChildItem -Path $env:GITHUB_WORKSPACE -Directory | Select-Object FullName
          $cs = Get-ChildItem -Path $env:GITHUB_WORKSPACE -Filter *.csproj -Recurse | Select-Object -Expand FullName
          Write-Host "Found csproj(s):"; $cs

      - name: Publish (.NET)
        run: |
          $ErrorActionPreference = 'Stop'
          Set-StrictMode -Version Latest
          $ws = $env:GITHUB_WORKSPACE

          if ([string]::IsNullOrWhiteSpace($env:PROJ_DIR)) {
            $proj = Get-ChildItem -Path $ws -Filter *.csproj -Recurse | Select-Object -First 1 -ExpandProperty FullName
            if (-not $proj) { throw "No .csproj found under $ws. Commit your project and push again, or set PROJ_DIR." }
          } else {
            $proj = Join-Path $ws $env:PROJ_DIR
            if (-not (Test-Path $proj)) { throw "PROJ_DIR does not exist: $proj" }
            if ((Get-Item $proj).PSIsContainer) {
              $c = Get-ChildItem -Path $proj -Filter *.csproj | Select-Object -First 1
              if (-not $c) { throw "No .csproj inside $proj" }
              $proj = $c.FullName
            }
          }

          Write-Host "Using project: $proj"
          $projFile = Split-Path $proj -Leaf
          $assembly = [IO.Path]::GetFileNameWithoutExtension($projFile)
          $pub = Join-Path $ws 'publish'

          & "${{ env.DOTNET_EXE }}" restore $proj
          if ($LASTEXITCODE -ne 0) { throw "dotnet restore failed with exit code $LASTEXITCODE" }

          & "${{ env.DOTNET_EXE }}" publish $proj -c Release -o $pub
          if ($LASTEXITCODE -ne 0) { throw "dotnet publish failed with exit code $LASTEXITCODE" }

          if (-not (Test-Path $pub)) { throw "Publish output not found: $pub" }

          # store for next steps
          "ASSEMBLY_NAME=$assembly" | Out-File -FilePath $env:GITHUB_ENV -Append -Encoding utf8

      - name: Mirror to TARGET_DIR (robocopy)
        run: |
          $ErrorActionPreference = 'Stop'
          $pub    = Join-Path $env:GITHUB_WORKSPACE 'publish'
          $target = "${{ env.TARGET_DIR }}"
          if (-not (Test-Path $pub))    { throw "Publish output not found: $pub" }
          if (-not (Test-Path $target)) { New-Item -ItemType Directory -Path $target | Out-Null }

          # Robocopy exit codes: 0,1,2,3,5,6,7 = success; >=8 = failure
          robocopy $pub $target /MIR /NFL /NDL /NJH /NJS /NP
          $rc = $LASTEXITCODE
          Write-Host "Robocopy exit code: $rc"
          if ($rc -ge 8) {
            throw "Robocopy failed with exit code $rc"
          } else {
            # normalize success to 0 so the step doesn't fail on rc=1,2,3,5,6,7
            $global:LASTEXITCODE = 0
          }

      - name: Restart app (kill port & start new)
        run: |
          $ErrorActionPreference = 'Stop'
          $port = [int]"${{ env.PORT }}"
          $dll  = Join-Path "${{ env.TARGET_DIR }}" "$($env:ASSEMBLY_NAME).dll"

          Write-Host "Looking for DLL at: $dll"
          if (-not (Test-Path $dll)) { throw "App DLL not found: $dll" }

          $c = Get-NetTCPConnection -LocalPort $port -ErrorAction SilentlyContinue |
               Where-Object State -eq 'Listen' | Select-Object -First 1
          if ($c) {
            Write-Host "Killing PID $($c.OwningProcess) on port $port"
            Stop-Process -Id $c.OwningProcess -Force
          }

          Start-Sleep -Seconds 1
          Write-Host "Starting app: $dll on http://0.0.0.0:$port"
          Start-Process -FilePath "${{ env.DOTNET_EXE }}" -ArgumentList @($dll,'--urls',"http://0.0.0.0:$port") -WindowStyle Hidden

          Start-Sleep -Seconds 2
          Write-Host "Health check http://127.0.0.1:$port/"
          $r = Invoke-WebRequest -Uri "http://127.0.0.1:$port/" -UseBasicParsing -TimeoutSec 6
          Write-Host "Health status: $($r.StatusCode)"
          if ($r.StatusCode -ne 200) { throw "Health check failed: $($r.StatusCode)" }

          # clean native exit code for the step
          $global:LASTEXITCODE = 0
